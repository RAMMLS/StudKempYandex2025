ПРИКЛАДНАЯ ДИСКРЕТНАЯ МАТЕМАТИКА

2009 Математические основы информатики и программирования №3(5)

УДК 004.94
МЕТОД АВТОМАТИЗИРОВАННОГО ПОИСКА

ПРОГРАММНЫХ ОШИБОК В АЛГОРИТМАХ ОБРАБОТКИ
СЛОЖНОСТРУКТУРИРОВАННЫХ ДАННЫХ1

А.Н. Макаров
ФГНУ «ГНТЦ „Наука“», г. Москва, Россия

E-mail: byalex@mail.ru

Рассмотрен разработанный автором метод поиска программных ошибок в про-
граммном обеспечении при отсутствии исходных текстов. Метод основан на стрес-
совом тестировании совместно с автоматической трассировкой программного
обеспечения. При этом наборы тестовых данных могут формироваться статиче-
ски или динамически на основе результатов трассировки.

Ключевые слова: компьютерная безопасность, тестирование, программная
ошибка.

Введение
При разработке программных комплексов часто решается задача по интеграции

в них программных модулей, для которых отсутствуют исходные коды и сопроводи-
тельная техническая документация. Для обеспечения надежности функционирования
комплекса в целом может потребоваться выполнить анализ бинарного кода использу-
емых модулей.

В данном случае под анализом бинарного кода подразумевается проверка коррект-
ности работы программного обеспечения (ПО) и отсутствия программных ошибок.
Существуют различные классификации ошибок, встречающихся в ПО [1, 2]. Далее
считаем, что программная ошибка — это ошибка реализации ПО, допущенная разра-
ботчиками на этапе кодирования. Проявлением программной ошибки является ава-
рийное завершение процесса, связанного с соответствующим ПО.

Применяют несколько основных подходов, которым отдается предпочтение при ре-
шении задачи тестирования бинарного кода [3, 4]:
— обратная инженерия (reverse engineering) — применяется с целью получения ПО на

языке ассемблера или на языке высокого уровня;
— анализ двоичного кода — предполагает наличие анализирующего приложения, ко-

торое читает собранное ПО и просматривает его с применением некоторых эври-
стических правил;

— тестирование нагрузкой или стрессовое тестирование — используется набор фай-
лов сценариев, которые посылают ПО разнообразные входные данные различного
размера и структуры.
В последнее время получил распространение один из видов стрессового тестиро-

вания—фазинг (fuzzing) [1, 5, 6]. Его преимущество — возможность быстрого полу-
чения результатов. Выделяют два вида фазинга — мутационный (mutation fuzzing) и
генерационный (generation fuzzing). В мутационном фазинге предполагается внесение

1Результаты работы докладывались на Международной конференции с элементами научной шко-
лы для молодёжи, г. Омск, 7–12 сентября 2009 г.



118 А. Н. Макаров

искажений в обрабатываемые входные данные, тогда как генерационный фазинг пред-
полагает создание входных данных на основе определенных правил.

На основе мутационного фазинга автором был разработан метод автоматизирован-
ного поиска программных ошибок (АППО), обладающий следующими свойствами:
— метод ориентирован на применение в условиях отсутствия исходного кода исследу-

емого ПО;
— метод предназначен для выявления ошибок кодирования («программистских» оши-

бок) ПО, которые, как правило, трудно выявить, основываясь на формальных ме-
тодах верификации ПО;

— метод является динамическим (анализ исследуемого ПО проводится во время его
работы, т. е. исследованию подвергается не само ПО, а процесс, порожденный ПО);

— метод применим для тестирования широкого спектра ПО, например ПО или про-
граммных компонент, обрабатывающих файлы с нетривиальной внутренней струк-
турой;

— метод не ориентирован на применение в рамках какой-либо конкретной аппаратно-
программной платформы.
Предлагаемый метод представляет сложноструктурированные данные в виде при-

веденной ниже модели структур сущностей-данных.

1. Модель структур сущностей-данных
Опишем модель структур сущностей-данных, которую используем при описании

метода АППО. Дадим определение.
Определение 1. ПО, для которого проводится анализ корректности реализации

с помощью метода АППО, будем называть исследуемым ПО.
Сущности-данные, обрабатываемые исследуемым ПО, как правило, имеют внут-

реннюю структуру (структуру данных). При этом даже в случае, когда ПО обрабаты-
вает явно неструктурированные данные (поток данных), можно считать, что данные
имеют структуру вида последовательности байт (бит или слов). С использованием [7]
дадим определения и сделаем предположение.

Определение 2. Структура —иерархическая организация взаимосвязанных дан-
ных, обладающая свойствами, которые позволяют выделить структуру среди прочих
и отнести ее к определенному типу. Структуры, относящиеся к одному типу, по опре-
делению обладают одинаковой организацией взаимосвязи данных.

Определение 3. Элементарная структура — один байт. По определению каж-
дая структура, кроме элементарной, в соответствии с ее иерархической организацией
состоит из вложенных в нее структур. Значение каждой структуры представляется
последовательностью (строкой) байт. При этом длину данной последовательности на-
зовем размером структуры.

Определение 4. Тип структуры — атрибут структуры, однозначно задающий
множество значений, которые могут принимать структуры данного типа, и набор опе-
раций, выполнимых над ними.

Определение 5. Обработчик структуры — совокупность кода исследуемого ПО,
осуществляющего обработку структуры. Обработчик однозначно идентифицирует



Метод поиска программных ошибок 119

структуру. Структуру назовем известной в случае, когда известен ее обработчик (пол-
ностью описаны алгоритмы, реализованные в исследуемом ПО для обработки данной
структуры).

Замечание 1. Если у двух структур одинаковый обработчик, то эти структуры
имеют одинаковый тип. Две однотипные структуры могут иметь различные обработ-
чики, и, следовательно, структуры следует считать различными.

Предположение 1. Каждой сущности-данным, обрабатываемой исследуемым
ПО, соответствует некоторая структура.

Используем следующие обозначения:
Ω —множество структур, обрабатываемых исследуемым ПО;
Ω∗ —множество всех конечных последовательностей структур из множества Ω;
Ωknow ⊂ Ω —множество известных структур;
T —множество типов структур;
byte ∈ T — тип элементарной структуры;
Λ ∈/ T — специальный символ, означающий, что тип структуры не может быть опре-

делен (исследуемое ПО может обрабатывать сущности-данные, содержащие структу-
ры, определение типов которых затруднено);

Ωtype ⊂ Ω —множество структур, тип которых определен;
Θ —множество обработчиков структур в исследуемом ПО (точное описание эле-

ментов данного множества не является существенным; потенциально оно может быть
получено с использованием методов обратной инженерии);

∆ ∈/ Θ — специальный символ, означающий, что обработчик структуры неизвестен
(отсутствует полное описание алгоритмов, реализованных в исследуемом ПО для об-
работки некоторой структуры);

B = {0⋃, . . . , 255}—множество значений элементарной структуры;
Bn = {(b1, . . . , bn)}—множество всех последовательностей длины n > 1, где bi ∈ B;
B∗ = n>1B

n —множество всех последовательностей конечной длины из элемен-
тов в B.

Определение 6. Определим λ : Ω→ N—функцию, задающую размер структур,
где N—множество натуральных чисел, и υ : Ω → B∗ —функцию, задающую значе-
ние структур. При этом по определению каждое значение структуры α ∈ Ω задается
последовательностью из множества Bλ(α).

Определение 7. Определим τ : Ω→ T ∪{Λ}—функцию, задающую типы струк-
тур, ω : Ω → Θ ∪ {∆}—функцию, задающую для каждой структуры ее обработчик;
σ : Θ → N—функцию, задающую для каждого обработчика объем кода (в тысячах
строк кода, ТСК). По определению выполняются следующие условия:
— для двух структур α1, α2 ∈ Ω справедливо равенство α1 = α2 тогда и только тогда,

когда справедливо равенство ω(α1) = ω(α2);
— структура α ∈ Ω является известной (α ∈ Ωknow) тогда и только тогда, когда вы-

полняется условие ω(α) 6= ∆ ;
— если у структуры α ∈ Ω не определен тип (τ(α) = Λ), то она является неизвестной

(α ∈/ Ωknow, ω(α) = ∆);
— если у структуры α ∈ Ω определен тип (α ∈ Ωtype), то выполняется условие

τ(α) 6= Λ;
— у известных структур определен их тип; таким образом, выполняется условие

Ωknow ⊂ Ωtype.



120 А. Н. Макаров

Определение 8. Зададим на множестве типов структур T отношение частичного
порядка «6» (отношение «быть подтипом»). При этом тип t1 ∈ T является подтипом
типа t2 ∈ T (t1 6 t2) тогда и только тогда, когда структура типа t2 содержит структуру
типа t1. Если t1 6 t2 и t1 6= t2, то будем записывать t1 < t2.

Определение 9. Множество базовых типов T0 ⊂ T —подмножество множества
типов T , такое, что выполняется условие byte ∈ T0 и для любого t ∈ T0 не существует
типа s ∈ T\{byte}, такого, что справедливо неравенство s < t. Зададим множество
производных типов T1 = T\T0.

Замечание 2. Примерами базовых типов могут являться тип «строка» или тип
«числовая переменная».

Определение 10. Будем говорить, что структура α ∈ Ω является структурой
с базовым типом, если выполняется условие τ(α) ∈ T0. Будем говорить, что структу-
ра α является структурой с производным типом, если выполняется условие τ(α) ∈ T1.

Определение 11. Определим HT : T → 2T —функцию иерархии типов, сопо-
ставляющую каждому типу t ∈ T\{byte} множество типов HT (t) ⊂ T и удовлетво-
ряющую условию: если r ∈ HT (t), то r < t и не существует типа s ∈ T , такого, что
r < s < t. Положим HT (byte) = ∅ .

Определение 12. Зададим на множестве структур Ω отношение частичного по-
рядка «6» (отношение «быть подструктурой»). При этом структура α ∈ Ω является
подструктурой β ∈ Ω (α 6 β) тогда и только тогда, когда структура β содержит струк-
туру α. Если α 6 β и α 6= β, то будем записывать α < β. По определению выполняется
условие: если α 6 β, то τ(α) 6 τ(β) и λ(α) 6 λ(β).

Замечание 3. Возможны случаи, когда две различные структуры α1, α2 ∈ Ω,
α1 6= α2, имеют одинаковый тип (τ(α1) = τ(α2)), но при этом их обработчики различ-
ны (ω(α1) 6= ω(α2)). Например, это возможно, когда структура — строка α1, входящая в
состав структуры «массив строк», имеет обработчик, отличный от обработчика струк-
туры— строки α2, входящей в состав структуры «список строк». Таким образом, для
рассмотренных структур выполняются условия τ(α1) = τ(α2) и ω(α1) 6= ω(α2). При
этом любая из этих структур может являться либо известной, либо неизвестной.

Определение 13. Определим HΩ : Ω → Ω∗ —функцию иерархии структур, со-
поставляющую каждой структуре α ∈ Ω, такой, что τ(α) 6= byte, конечную последова-
тельность структур HΩ(α) = (α1, . . . , αm) ∈ Ωm, m > 1, удовлетворяющих условиям:
αi < α и не существует структуры β ∈ Ω, такой, что αi < β < α (i = 1, . . . ,m). Если
τ(α) = byte, то HΩ(α) —пустая последовательность (длины 0).

Замечание 4. Если для структуры α ∈ Ω справедливо равенство HΩ(α) =
(α1, . . . , αm), то из определений 8, 11, 12 и 13 следует, что справедливо равенство
HT (α) = {τ(α1), . . . , τ(αm)}.

Замечание 5. Возможен случай, когда типы и значения структуры α ∈ Ω и
входящих в нее структур не определены. Тогда можно считать, что τ(α) = Λ и
HΩ(α) = (α1, . . . , αλ(α)), где для 1 6 i 6 λ(α) справедливо равенство τ(αi) = byte
(структура α состоит из последовательности элементарных структур, длина которой
равна размеру структуры α). В то же время возможен случай, когда тип структуры α



Метод поиска программных ошибок 121

не определен (τ(α) = Λ) и она состоит из последовательности структур известных ти-
пов, не совпадающих с элементарным. Например, структура α может состоять только
из структур— строк и структур— числовых констант. При этом в совокупности на-
значение или взаимосвязь входящих в структуру α структур будут оставаться неиз-
вестными и, следовательно, тип структуры α будет не определен. Другой случай: тип
структуры α определен (α ∈ Ωtype), а множество HΩ(α) неизвестно. Например, струк-
тура α представляет собой doc-файл, тогда как внутренние структуры, составляющие
doc-файл, неизвестны.

Замечание 6. Так как на множестве структур и на множестве типов структур
заданы отношения частичного порядка, то для наглядности представления иерархии
структур или иерархии типов структур можно использовать ориентированный граф.
При этом вершинами графа являются структуры или их типы, а ребра соответствуют
отношению частичного порядка между вершинами.

Часто при исследовании структур данных не анализируются форматы и порядок
их представления непосредственно в сущностях-данных (файлах, потоках данных), об-
рабатываемых исследуемым ПО. Например, как правило, предполагается, что данные
структур (последовательности соответствующих им байт) не могут перемешиваться. В
рассматриваемом методе АППО осуществляется поиск программных ошибок исследуе-
мого ПО, являющихся следствием, в том числе некорректной обработки ПО структур
в сущностях-данных. Значит, целесообразно осуществить анализ структур с учетом
возможного их представления в сущностях-данных. Дадим определение.

Определение 14. Пусть структуры α, β ∈ Ω такие, что α < β (по определе-
нию 12 выполняется условие λ(α) 6 λ(β)). Представлением структуры α в струк-
туре β назовем подпоследовательность последовательности υ(β), соответствующую
значению структуры υ(α). При этом по определению задана инъективная функция
ψ : {1, . . . , λ(α)} → {1, . . . , λ(β)} (которую назовем функцией отображения структу-
ры α в структуру β), такая, что для любых значений структур υ(α) = (a1, . . . , aλ(α)) и
υ(β) = (b1, . . . , bλ(β)) справедливы равенства ai = bψ(i), где 1 6 i 6 λ(α).

Замечание 7. В соответствии с определением 14 для структур α, β ∈ Ω, таких,
что α < β, элементы последовательности υ(β), соответствующие представлению струк-
туры α в структуре β, могут следовать в произвольном порядке и между ними могут
содержаться элементы, не принадлежащие значению υ(α) структуры α.

В ПО, как правило, структуры базовых типов являются наиболее распространен-
ными. В связи с этим производители ПО стремятся упростить представление этих
структур в сущностях-данных, что упрощает разработку обработчиков структур ба-
зовых типов. Таким образом, целесообразно использовать следующее предположение.

Предположение 2. Пусть структуры α, β ∈ Ω такие, что α < β и структу-
ра α имеет базовый тип (τ(α) ∈ T0). Тогда функция ψ отображения структуры α
в структуру β обладает следующим свойством: для 0 6 i < λ(α) выполняется условие
ψ(i+ 1) = ψ(i) + 1 = ψ(1) + i.

Таким образом, описана модель структур, содержащихся в сущностях-данных, об-
рабатываемых исследуемым ПО.

2. Модель процесса исследуемого ПО
Рассматриваемый метод АППО является динамическим [8], то есть он ориентиро-

ван на анализ программных ошибок в исследуемом ПО, когда оно является активным



122 А. Н. Макаров

(выполняется как процесс ОС). В связи с этим опишем модель процесса ОС, которую
используем при описании метода АППО. Дадим определения.

Определение 15. Процессом ОС, реализующим исследуемое ПО (процессом ис-
следуемого ПО), назовем автомат P<S, I, p, s0>, где S —множество всех состояний
процесса; I ⊂ Ω∗ —множество входных данных; p : I × S → S —функция переходов
процесса из состояния в состояние; s0 ∈ S —начальное состояние процесса.

Замечание 8. Функция перехода p задается последовательностью исполняемых
инструкций кода исследуемого ПО, которое реализует процесс P .

Определение 16. Для каждого процесса исследуемого ПО P<S, I, p, s0> на мно-
жестве состояний S зададим множество аварийных состояний E ⊂ S\{s0}. При этом
по определению для каждого аварийного состояния e ∈ E процесса P выполняется
условие: для любых входных данных i ∈ I справедливо равенство p(i, e) = e (процесс,
перейдя в аварийное состояние, не может перейти ни в какое другое состояние).

Если процесс попадает в аварийное состояние, то будем говорить, что процесс P
завершился аварийно.

Замечание 9. Как правило, для процесса любого исследуемого ПО множество
аварийных состояний E можно считать всегда известным, так как оно задается средой
ОС, в которой функционирует процесс. Процесс аварийно завершается тогда и только
тогда, когда выполнение очередной машинной инструкции «физически» невозможно
(например, нет доступа к памяти или процессор не может декодировать машинную
команду) [9].

Определение 17. Эталонные входные данные — входные данные, которые, как
правило, созданы процессом исследуемого ПО, и их обработка по определению не при-
водит к его аварийному завершению. Если эталонные входные данные являются фай-
лом, который подается на вход процессу исследуемого ПО, то назовем его эталонным
входным файлом.

Определение 18. Пусть P<S, I, p, s0>—процесс исследуемого ПО. Будем гово-
рить, что в процессе P содержится программная ошибка, если существуют входные
данные i ∈ I, такие, что справедливо условие p(i, s0) ∈ E. Программная ошибка —
это ошибка в коде исследуемого ПО (как правило, допущенная его разработчиками),
которая приводит к аварийному завершению процесса исследуемого ПО на соответ-
ствующих входных данных.

Используем обозначения:
IS ⊂ I —множество эталонных входных данных для процесса P<S, I, p, s0>, при

этом по определению 17 для любых эталонных входных данных i ∈ IS и любого состо-
яния s ∈ S\E выполняется условие p(i, s) ∈/ E;

IF ⊂ I —множество входных данных, при обработке которых происходит аварий-
ное завершение процесса P<S, I, p, s0>, при этом по определениям 17 и 18 справедливо
равенство IF ∩ IS = ∅;

(e, i1, . . . , in) — траектория программной ошибки процесса P<S, I, p, s0> исследуе-
мого ПО; при этом e ∈ E и (i1, . . . , in) —последовательность входных данных длины
n > 1, подаваемых на вход процесса P<S, I, p, s0>, где для 1 6 k 6 n выполняется
условие ik ∈ I и справедливо равенство p(in, p(in−1, . . . p(i2, p(i1, s0)) . . . )) = e;

F —множество всех траекторий программных ошибок процесса P<S, I, p, s0> ис-
следуемого ПО.



Метод поиска программных ошибок 123

В дальнейшем целесообразно использовать следующее предположение.
Предположение 3. В любом исследуемом ПО существуют программные ошибки.
В рамках предположения 3 для процесса P<S, I, p, s0> любого исследуемого ПО су-

ществуют входные данные (i1, . . . , in) ∈ I, где n > 1, такие, что справедливо равенство
p((i1, . . . , in), s0) ∈ E (при обработке входных данных (i1, . . . , in) процесс P<S, I, p, s0>
завершается аварийно). При этом (p((i1, . . . , in), s0), i1, . . . , in) ∈ F является траекто-
рией программной ошибки процесса P<S, I, p, s0>.

Таким образом, описана модель процесса исследуемого ПО.

3. Метод автоматизированного поиска программных ошибок
Для применения метода АППО разработано программное средство (ПС), реализу-

ющее следующие функции:
— формирование входных данных для исследуемого ПО;
— проведение тестов (активизация исследуемого ПО— запуски процесса исследуемого

ПО и передача ему подготовленных входных данных);
— регистрация программных ошибок, возникших в результате обработки входных

данных процессом исследуемого ПО.
Опишем метод АППО.
Метод АППО. Пусть дано исследуемое ПО. Применение метода АППО состоит

в выполнении следующих шести этапов.
Этап 1. Проводится анализ доступной информации об исследуемом ПО, в том

числе осуществляется анализ:
— доступной документации;
— доступных спецификаций структур данных, обрабатываемых исследуемым ПО;
— доступных фрагментов исходных кодов модулей исследуемого ПО или ОС (т. е.

в среде, где активизируется исследуемое ПО), которые реализуют обработчики
структур, содержащихся во входных данных исследуемого ПО.
В результате выполнения этапа 1 для исследуемого ПО:

— задаются множества структур Ω, известных структур Ωknow, типов структур T ,
структур известных типов Ωtype и обработчиков структур Θ, функции λ, υ, τ , ω,
HT и HΩ;

— описывается, как в среде ПС исследуемое ПО может быть активизировано, т. е.
запущен процесс P<S, I, p, s0> исследуемого ПО, и как этому процессу могут пе-
редаваться входные данные (множество I ⊂ Ω∗); описывается множество входных
данных I и их вид (файл, сетевые пакеты или их последовательность, последова-
тельность событий нажатия клавиш на клавиатуре).
Этап 2. На основе результатов выполнения этапа 1 выбираются структуры, для

которых является целесообразным восстановление и анализ кода их обработчиков. Вы-
бор структур может быть осуществлен с учетом следующих факторов:
— наличия ресурсов для проведения детального анализа (дизассемблирование, отлад-

ка, тестирование, эксперименты на макете) кода обработчиков структур в исследу-
емом ПО;

— предположений о наличии программных ошибок в обработчиках выбранных струк-
тур;

— предположений о возможности восстановления кода обработчиков структур за до-
ступное время.



124 А. Н. Макаров

Для выбранных структур осуществляется восстановление и анализ кода их обра-
ботчиков, в результате по определению 5 данные структуры становятся известными.
Таким образом, уточняются значения множеств Ω, Ωknow, T , Ωtype и Θ, функций λ, υ,
τ , ω, HT и HΩ.

Этап 3. На основе результатов выполнения этапов 1 и 2 выбираются неизвестные
структуры (структуры α ∈/ Ωknow), для которых определен тип (структуры из множе-
ства Ωtype) или определение их типа является целесообразным. Выбор структур может
быть осуществлен с учетом следующих факторов:
— наличия ресурсов для проведения детального анализа и описания структур;
— предположений о наличии программных ошибок в обработчиках структур выбран-

ных типов;
— предположений о возможности описания структур за доступное время.

Для выбранных структур осуществляется определение их типа. Таким образом,
уточняются значения множеств T и Ωtype, функций λ, υ, τ , HT и HΩ.

Этап 4. ПС осуществляет автоматизированный поиск программных ошибок. По-
иск заключается в том, что в среде ПС запускается процесс P<S, I, p, s0> исследу-
емого ПО (каждый запуск процесса назовем тестом). При выполнении одного теста
процессу P<S, I, p, s0> передаются входные данные, сформированные разработанны-
ми процедурами формирования входных данных (ПФВД; более подробное описание
ПФВД рассмотрено далее) из эталонных входных данных путем модификации значе-
ния структур из множества Ωtype (множества структур, тип которых определен). Если
в результате обработки входных данных процесс P<S, I, p, s0> завершился аварийно
(найдена программная ошибка), то управление возвращается ПС, которое фиксирует
состояние процесса P<S, I, p, s0> и входные данные, обработка которых стала причи-
ной его аварийного завершения. При этом ПС восстанавливает корректность процесса
P<S, I, p, s0> для дальнейшего тестирования.

Этап 5. На основе результатов выполнения этапов 1, 2 и 3 выбираются структуры,
тип которых не определен и которые целесообразно считать элементарными (считать,
что тип таких структур равен byte). Выбор структур может быть осуществлен с учетом
следующих факторов:
— предположений о наличии программных ошибок в обработчиках данных структур;
— наличия ресурсов для проведения за доступное время тестов исследуемого ПО при

обработке входных данных, в которых модифицируются значения данных струк-
тур.
Задается Ωbyte —множество структур, выбранных на этапе 5.
Этап 6. ПС осуществляет тестирование исследуемого ПО. При выполнении одного

теста процессу P<S, I, p, s0> передаются входные данные, сформированные ПФВД из
эталонных входных данных путем модификации значения структур из множества Ωbyte

(множества структур, которые целесообразно считать элементарными). Если в резуль-
тате обработки входных данных процесс P<S, I, p, s0> завершился аварийно (найде-
на программная ошибка), то управление возвращается ПС, которое фиксирует со-
стояние процесса P<S, I, p, s0> и входные данные, обработка которых стала причи-
ной его аварийного завершения. При этом ПС восстанавливает корректность процесса
P<S, I, p, s0> для дальнейшего тестирования.

Прокомментируем метод АППО.
Замечание 10. Этап 1 метода АППО состоит в предварительном исследовании

ПО, и время, требуемое для его выполнения, целесообразно не учитывать при оценке



Метод поиска программных ошибок 125

результативности метода АППО. Кроме того, выбор структур, которые целесообразно
считать элементарными, на этапе 5 не требует затрат времени, так как может быть
осуществлен, например, случайно из неизвестных структур входных данных, тип ко-
торых не определен.

Замечание 11. Этап 2 предполагает поиск программных ошибок в сложно-
структурированных данных на основе «классического» подхода (дизассемблирование
и отладка). При выполнении второго этапа следует соблюдать компромисс. С одной
стороны, знание всех исходных кодов обработчиков структур позволит решить задачу
более эффективно (например, на основе средств анализа исходных кодов). С другой
стороны, временные затраты, требуемые для восстановления исходных кодов, могут
оказаться неприемлемыми. Отметим, что этап 2 может проводиться параллельно с
этапами 3–6.

Можно также предложить, что оценка результативности метода АППО должна
учитывать следующие параметры:
— среднее время обнаружения программной ошибки;
— средний объем кода обработчиков структур;
— среднее число программных ошибок, выявленных на этапах 2, 4 и 6;
— среднее время проведения одного теста на этапах 4 и 6;
— относительное число аварийных завершений, являющееся усредненным отношени-

ем числа аварийно завершившихся тестов к общему числу проведенных тестов на
этапах 4 и 6.
В настоящий момент для эмпирической оценки результативности метода исполь-

зуется относительное число аварийных завершений (обозначим его через K). Опыт
применения описанного метода показал, что при значении K около 0,1% (на 1000 те-
стов один тест завершается аварийно) и выше результативность метода для данного
ПО можно признать удовлетворительной. Поскольку время проведения одного теста,
как правило, занимает не более 10 с (на типовом компьютере), то при значении K
порядка 0,1% и выше программные ошибки будут найдены за приемлемое время. Экс-
перименты показали, что существует ПО, для которого значение K достигает 5–6%.

Замечание 12. После того как программная ошибка будет найдена, наиболее
разумно связаться с разработчиками программных модулей и сообщить об ошибке. К
сожалению, это не всегда возможно. Также следует учесть, что если информация о
программной ошибке будет принята разработчиками к сведению, то до внесения соот-
ветствующих исправлений может пройти достаточно большой срок. Если проявления
программной ошибки не допустимы, то одним из возможных решений является органи-
зация дополнительной фильтрации входных данных. Как минимум, дополнительная
фильтрация будет блокировать входные данные, для которых уже были выявлены
программные ошибки в результате применения метода АППО.

В заключение опишем назначение ПФВД в алгоритме АППО.

4. Процедуры формирования входных данных
Применение метода выявило существенную зависимость между параметром K и

применяемыми при тестировании на 4 и 6 этапах ПФВД. Были разработаны общие
ПФВД (насколько это возможно), применимые к большинству исследуемого ПО. Тем
не менее для повышения значения параметра K при тестировании конкретного ПО
требуется разработка (или модификация существующих) индивидуальных ПФВД.



126 А. Н. Макаров

ПФВД должны сформировать входные данные, которые процессом исследуемого
ПО будут приняты к обработке.

На этапах 4 и 6 метода АППО генерируются наборы входных данных, на которых
запускается процесс исследуемого ПО P<S, I, p, s0>. Входные данные генерируются
ПФВД из эталонных входных данных путем модификации значения структур из мно-
жеств Ωtype и Ωbyte.

Используются ПФВД двух видов:
— статические ПФВД, основанные на различных эвристических правилах, которые

применяются для преобразования структур без учета особенностей их обработки
процессом исследуемого ПО;

— динамические ПФВД, преобразующие эталонные входные данные по правилам,
которые формируются на основе трассировки процесса ПО.
Для статических ПФВД задаются различные эвристические правила преобразова-

ния структур из множеств Ωtype и Ωbyte (этапы 4 и 6). Если структуры, содержащиеся
в множествах Ωtype и Ωbyte, будут найдены во входных эталонных данных, то они будут
преобразованы ПФВД.

Для повышения результативности метода было решено сочетать стрессовое тести-
рование и динамический анализ на основе трассировки процесса исследуемого ПО.
Непосредственно перед выполнением этапов 4 и 6 для каждого эталонного файла вы-
полняются следующие действия:
— собирается трасса процесса исследуемого ПО на эталонном входном файле;
— уточняются значения множеств T , Ωtype и Ωbyte, функций λ, υ, τ , HT и HΩ;
— выбирается статическая ПФВД, наиболее подходящая для проведения очередного

теста.
На основе трассы процесса исследуемого ПО в ПС, реализующем метод, введены

вспомогательные механизмы— это механизм оценки покрытия программного кода, за-
действованного при обработке входных данных, и механизм определения обработчиков
структур на основе сравнения трасс.

Заключение
Разработанный автором метод применяется для анализа надежности ПО в ОС се-

мейства Windows 2003/XP/Vista, а также частично опробован в ОС Windows CE и
ОС Linux. Эксперименты показали хорошие результаты для ПО, обрабатывающего
сложноструктурированные форматы файлов.

Реализованное на основе метода ПС работает в автоматическом режиме, не тре-
бует существенных усилий со стороны оператора ПС. В качестве результатов работы
ПС предоставляет множество сигнатур для организации дополнительной фильтрации
входных данных, вызывающих аварийное завершение в ПО, доступ к исходным кодам
которого отсутствует. Таким образом, может быть повышена надежность функциони-
рования разрабатываемых программных комплексов.

В настоящий момент ведутся работы по исследованию и оценке параметров ре-
зультативности метода с целью анализа его возможностей и расширения границ
применения.

ЛИТЕРАТУРА
1. Козиол Д., Личфилд Д., Эйтэл Д. и др. Искусство взлома и защиты системы. СПб.: Пи-

тер, 2006. 416 с.



Метод поиска программных ошибок 127

2. Ховард М., Лебланк Д. Защищенный код. 2-е изд. М.: Издательско-торговый дом «Русская
Редакция», 2005. 704 с.

3. Хогланд Г., Мак-Гроу Г. Взлом программного обеспечения: анализ и использование кода.
М.: Издательский дом «Вильямс», 2005. 400 с.

4. Eilam E. Reversing: Secrets of Reverse Engineering. Wiley Publishing, 2005. 589 p.
5. Miller С., Peterson Z.N. J. Analysis of Mutation and Generation-Based Fuzzing —

securityevaluators.com/files/papers/analysisfuzzing.pdf— 2007.
6. Neystadt J. Automated Penetration Testing with White-Box Fuzzing — msdn.microsoft.com/

en-us/library/cc162782.aspx—Microsoft Corporation, 2008.
7. Левитин А.В. Алгоритмы: введение в разработку и анализ. М.: Издательский дом «Ви-

льямс», 2006. 576 с.
8. Калбертсон Р., Браун К., Кобб Г. Быстрое тестирование. М.: Издательский дом «Ви-

льямс», 2002. 384 с.
9. Intel Architecture Software Developer’s Manual. V. 3: System Programming. Intel, 1999.