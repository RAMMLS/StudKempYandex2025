ПРИКЛАДНАЯ ДИСКРЕТНАЯ МАТЕМАТИКА

2009 Математические основы компьютерной безопасности №1(3)

МАТЕМАТИЧЕСКИЕ ОСНОВЫ
КОМПЬЮТЕРНОЙ БЕЗОПАСНОСТИ

УДК 004.94

ПОДХОДЫ К ПОСТРОЕНИЮ ДП-МОДЕЛИ ФАЙЛОВЫХ СИСТЕМ
П.В. Буренин

ООО «Твест», г. Тверь

E-mail: troy1f4@mail.ru

В статье приводятся подходы к созданию ДП-модели файловых систем, в основе
которой используется семейство ДП-моделей компьютерных систем с дискрецион-
ным управлением доступом. В рамках ДП-модели рассматриваются специфичные
для файловых систем условия функционирования субъектов, условия передачи
прав доступа и реализации информационных потоков, а также обосновываются
достаточные условия реализации в файловых системах запрещенных информаци-
онных потоков по памяти.

Ключевые слова: компьютерная безопасность, файловые системы, ДП-
модель.

С целью обеспечения возможности анализа условий получения недоверенными
субъектами контроля над доверенными субъектами, реализующими механизмы за-
щиты файловых систем (ФС), или условий создания недоверенными субъектами ин-
формационных потоков по памяти в обход механизмов защиты ФС построим на основе
ДП-модели с функционально-ассоциированными с субъектами сущностями (ФАС ДП-
модели, [1]) и разработанной Д.Н. Колеговым модели с функционально- и парамет-
рически-ассоциированными с субъектами сущностями с дискреционным управлением
доступом (ФПАС ДП-модели) ДП-модель файловых систем (или, сокращенно, ФС
ДП-модель).

При этом для построения ФС ДП-модели в ФАС и ФПАС ДП-модели внесены
изменения, позволяющие учитывать существенные особенности реализации механиз-
мов защиты современных ФС. Таким образом, в дальнейшем используем следующее
предположение.

Предположение 1. В рамках ФС ДП-модели выполняются следующие условия.
Условие 1. Во множестве сущностей выделено подмножество сущностей, защищен-

ных ФС и не являющихся субъектами.
Условие 2. Во множестве доверенных субъектов выделено подмножество субъек-

тов, обладающих правами доступа и реализующих доступ к сущностям, защищенным
ФС, и кодирование в них данных в случае, когда оно осуществляется ФС. Эти дове-
ренные субъекты реализуют информационные потоки по памяти между каждой сущ-
ностью, защищенной ФС, и соответствующей ей сущностью-образом, не являющейся
субъектом.

Условие 3. Доверенные или недоверенные субъекты, не реализующие доступ к сущ-
ностям, защищенным ФС, не обладают правами доступа и не могут получать доступ к
этим сущностям. При этом они могут обладать правами доступа или получать доступ
к сущностям-образам сущностей, защищенных ФС.



94 П.В. Буренин

Условие 4. В каждом состоянии системы кроме множества субъектов анализирует-
ся множество потенциальных доверенных субъектов (доверенных субъектов, которые
могут быть созданы в процессе функционирования системы для реализации доступа
к сущностям, защищенным ФС).

Условие 5. Кроме возможности создания новых субъектов из сущностей недове-
ренный субъект может создать доверенного субъекта в случае, когда недоверенный
субъект реализовал к себе информационные потоки по памяти от всех сущностей,
параметрически ассоциированных с потенциальным доверенным субъектом. При этом
недоверенный субъект получает контроль над созданным доверенным субъектом.

Условие 6. Каждый доверенный субъект не обладает правами доступа ко всем сущ-
ностям.

Условие 7. Доверенные субъекты, не реализующие доступ к сущностям, защищен-
ным ФС, в процессе функционирования системы не получают новые доступы к сущ-
ностям и не участвуют в создание информационных потоков к или от сущностей,
защищенных ФС.

Условие 8. Не рассматриваются информационные потоки по времени, право доступа
и доступ на запись в конец сущности.

Условие 9. В начальном состоянии системы недоверенные субъекты не реализу-
ют доступы к сущностям, к ним не имеют доступы другие субъекты и отсутствуют
информационные потоки по памяти с участием недоверенных субъектов.

В основе ФС ДП-модели использован классический подход (используемый, в том
числе, в семействе ДП-моделей КС с дискреционным, мандатным или ролевым управ-
лением доступом), состоящий в том, что каждая моделируемая КС представляется
абстрактной системой, каждое состояние которой представляется графом доступов,
каждый переход системы из состояния в состояние осуществляется в результате при-
менения одного из правил преобразования графов доступа.

В рамках предположения 1 используем следующие обозначения и определения
ФАС и ФПАС ДП-моделей:

— E = O ∪ C—множество сущностей, где O—множество объектов, C—множество
контейнеров и O ∩ C = ∅;

— S ⊂ E—множество субъектов;
— [s] ⊂ E —множество всех сущностей, функционально ассоциированных с субъек-

том s (при этом по определению выполняется условие s ∈ [s], и для каждого субъекта
множество сущностей, функционально с ним ассоциированных, не изменяется в про-
цессе функционирования системы);

— ]s[ ⊂ E—множество всех сущностей, параметрически ассоциированных с субъ-
ектом и потенциальным субъектом s (при этом по определению для каждого субъекта
множество сущностей, параметрически с ним ассоциированных, не изменяется в про-
цессе функционирования системы);

— LS —множество доверенных субъектов;
—NS —множество недоверенных субъектов, при этом по определению выполняется

равенство LS ∩NS = ∅;
— Rr = {read r, writer, executer, ownr} — множество видов прав доступа;
— Ra = {reada, writea} — множество видов доступа;
— Rf = {writem} — множество видов информационных потоков, где writem —ин-

формационный поток по памяти на запись в сущность.
Определение 1. Иерархией сущностей называется заданное на множестве сущ-

ностей E отношение частичного порядка «6», удовлетворяющее условию:



Подходы к построению ДП-модели файловых систем 95

если для сущности e ∈ E существуют сущности e1, e2 ∈ E, такие, что e 6 e2, e 6 e1,
то e1 6 e2 или e2 6 e1.

В случае, когда для двух сущностей e1, e2 ∈ E выполняются условия e1 6 e2 и
e1 6= e2, будем говорить, что сущность e1 содержится в сущности-контейнере e2, и
будем использовать обозначение e1 < e2.

Определение 2. Определим H : E → 2E —функцию иерархии сущностей, сопо-
ставляющую каждой сущности c ∈ E множество сущностей H(c) ⊂ E и удовлетворя-
ющую следующим условиям:

Условие 1. Если сущность e ∈ H(c), то e < c и не существует сущности-контейнера
d ∈ C, такой, что e < d, d < c.

Условие 2. Для любых сущностей e1, e2 ∈ E, e1 6= e2, по определению выполняются
равенство H(e1) ∩H(e2) = ∅ и условия:
— если o ∈ O, то выполняется равенство H(o) = ∅;
— если e1 < e2, то или e1, e2 ∈ E \ S, или e1, e2 ∈ S;
— если e ∈ E \ S, то H(e) ⊂ E \ S;
— если s ∈ S, то H(s) ⊂ S.

В рамках предположения 1 в ФС ДП-модели дополнительно используем следующие
обозначения:

— FSE ⊂ E \ S —множество сущностей, защищенных ФС;
— fs : FSE → E \ S —инъективная функция, которая ставит в соответствие каждой

сущности, защищенной ФС, соответствующую ей сущность-образ;
— PS —множество потенциальных доверенных субъектов, реализующих доступ к

сущностям из множества FSE ;
— FSS ⊆ LS ∩ S —множество доверенных субъектов, реализующих доступ к сущ-

ностям из множества FSE.
Будем считать, что в дальнейшем выполняется следующее предположение.
Предположение 2. В рамках ФС ДП-модели выполняются следующие условия.
Условие 1. Каждый доверенный субъект из множества FSS является функциональ-

но корректным, корректным относительно любой сущности и может обладать только
правами доступа на чтение и запись к сущностям из множества FSE и соответствую-
щим им сущностям-образам.

Условие 2. Каждый потенциальный доверенный субъект из множества PS может
обладать только правами доступа на чтение и запись к сущностям из множества FSE
и соответствующим им сущностям-образам и не может реализовать доступы к любым
сущностям или информационные потоки.

Условие 3. Из потенциального доверенного субъекта из множества PS может быть
создан только доверенный субъект из множества FSS. При этом множество PS не
изменяется в процессе функционирования системы.

Условие 4. Для каждого доверенного субъекта из множества FSS или потенциаль-
ного доверенного субъекта из множества PS множество параметрически ассоциирован-
ных с ним сущностей не пусто (для каждого s ∈ FSS ∪ PS справедливо неравенство
]s[ 6= ∅). Для каждого доверенного субъекта из множества FSS множество функци-
онально ассоциированных с ним сущностей состоит только из самого субъекта (для
каждого s ∈ FSS справедливо равенство [s] = {s}), и невозможно получение к нему
права доступа владения с использованием реализованного к нему информационного
потока по памяти.



96 П.В. Буренин

Условие 5. Для каждой сущности из множества FSE существует доверенный субъ-
ект из множества FSS или потенциальный доверенный субъект из множества PS, об-
ладающий правами доступа на чтение и запись к сущности и к соответствующей ей
сущности-образу (для каждой e ∈ FSE существует субъект s ∈ FSS ∪ PS, обладающий
правами доступа (s, e, read r), (s, e, writer), (s, fs(e), read r), (s, fs(e), writer)).

Условие 6. Каждый доверенный субъект, не входящий во множество FSS, обладает
всеми правами доступа ко всем сущностям, не входящим во множества FSE, FSS и
{e ∈ E: существует s ∈ S и e ∈ ]s[} (множество сущностей, параметрически ассоции-
рованных с субъектами).

В рамках предположений 1 и 2 дадим определение состояния системы.
Определение 3. Пусть определены множества S, PS, E, R ⊆ (S ∪PS)×E ×Rr,

A ⊆ S × E × Ra, F ⊆ E × E × Rf и функция иерархии сущностей H. Определим
G= (S, E, R ∪A ∪ F , H) —конечный помеченный ориентированный граф, без петель,
где элементы множеств S, PS, E являются вершинами графа, элементы множества
R ∪ A ∪ F —ребрами графа. Назовем G= (S, E, R ∪ A ∪ F , H) графом прав доступа,
доступов и информационных потоков или, сокращенно, графом доступов. При этом в
графе доступов будем использовать следующие обозначения:
— вершины из множества S (соответствующие субъектам) в графе доступов будут

обозначаться «•»;
— вершины из множества PS (соответствующие потенциальным субъектам) в графе

доступов будут обозначаться «◦»;
— вершины из множества E \ S (соответствующие сущностям, не являющимся субъ-

ектами) в графе доступов будут обозначаться «⊗»,
— каждое ребро графа доступов помечено одним из элементов множества Rr∪Ra∪Rf ;
— каждое ребро из множества R будет обозначаться стрелкой вида, представленного

на рис. 1,а;
— каждое ребро из множества A будет обозначаться стрелкой вида, представленного

на рис. 1,б ;
— каждое ребро из множества F , помеченное writem, будет обозначаться стрелкой

вида, представленного на рис. 1,в.

Рис. 1. Обозначения ребер графа доступов: а—ребро из множества R,
помеченное αr ∈ Rr; б—ребро из множества A, помеченное
αa ∈ Ra; в—ребро из множества F , помеченное writem

Используем также обозначения:
Σ(G*, OP ) — система, при этом:

— каждое состояние системы представляется графом доступов;
— G* — множество всех возможных состояний;
— OP —множество правил преобразования состояний, определенных в таблице.

G `op G′ —переход системы Σ(G*, OP) из состояния G в состояние G′ с использо-
ванием правила преобразования состояний op ∈ OP.



Подходы к построению ДП-модели файловых систем 97

Если для системы Σ(G*, OP) определено начальное состояние, то будем использо-
вать обозначение:

Σ(G*, OP , G0) — система Σ(G*, OP) с начальным состоянием G0.
При анализе правил преобразования состояний и траекторий функционирования

системы, в результате реализации которых возникают запрещенные информационные
потоки по памяти, применим подход, аналогичный использованному в рамках ФАС
ДП-модели и ФПАС ДП-модели. Кроме того, в соответствии с условием 7 предполо-
жения 1 доверенные субъекты, не входящие во множество FSS, в процессе функцио-
нирования системы не реализуют новые доступы к сущностям. В противном случае,
любой недоверенный субъект с помощью доверенных субъектов мог бы реализовать
к себе информационный поток по памяти от любой сущности, защищенной ФС, для
которой в системе существует соответствующий ей доверенный субъект из множества
FSS. Таким образом, будем считать, что в дальнейшем выполняется следующее пред-
положение.

Предположение 3. В процессе функционирования системы доверенные
субъекты:
— не дают недоверенным субъектам права доступа к сущностям;
— не берут у недоверенных субъектов права доступа к сущностям;
— не получают прав доступа владения к другим субъектам;
— не создают доверенных субъектов из потенциальных доверенных субъектов.

Кроме того, доверенные субъекты, не входящие во множество FSS, не реализуют
новые доступы к сущностям.

На основе предположения 3 дадим определение.
Определение 4. Назовем траекторию функционирования системы Σ(G*, OP)

траекторией без кооперации доверенных и недоверенных субъектов для передачи прав
доступа и реализации информационных потоков по памяти, если при ее реализации
используются монотонные правила преобразования состояний, и:
— доверенные субъекты не инициируют выполнения следующих правил преобразо-

вания состояний: take_right(αr, u, x, e), grant_right(αr, u, x, e), create_entity(x,
y, z), create_subject(x, y, z), potential_subject(u, ps, y), control(u, y, e), know(u, y),
access_read(u, e), access_write(u, e);

— доверенные субъекты могут инициировать выполнение правил преобразова-
ния состояний: own_take(αr, u, e), create_entity(x, y, z), create_subject(x, y, z),
find(u, e, e′), post(u, e, e′), pass(u, e, e′),

где u, y ∈ LS —доверенные субъекты, x ∈ NS —недоверенный субъект, ps ∈ PS —
потенциальный доверенный субъект, e, e′ — сущности, αr ∈ Rr—право доступа.

Таким образом, в рамках предположений 1 и 2 в дальнейшем будем рассматривать
траектории без кооперации доверенных и недоверенных субъектов для передачи прав
доступа и реализации информационных потоков по памяти. При этом по сравнению с
ФАС ДП-моделью и ФПАС ДП-моделью в ФС ДП-модели (таблица):
— заданы без использования информационных потоков по времени, права доступа

append r и доступа appenda условия и результаты применения монотонных пра-
вил преобразования состояний: take_right(αr, x, y, z), grant_right(αr, x, y, z),
own_take(αr, x, y), create_entity(x, y, z), create_subject(x, y, z), control(x, y, z),
know(x, y), access_read(x, y), access_write(x, y), find(x, y, z), post(x, y, z), pass(x,
y, z);



98 П.В. Буренин

— для обеспечения возможности создания доверенными субъектами информацион-
ных потоков по памяти при наличии у них доступов к сущностям изменены условия
применения правил find(x, y, z), post(x, y, z), pass(x, y, z);

— не рассматриваются правила flow(x, y, y′, z) и rename_entity(x, y, z), так как в
результате их применения только информационные потоки по времени;

— не рассматривается правило access_append(x, y), так как оно используется для
получения к сущности доступа appenda с применением права доступа append r;

— добавлено новое правило potential_subject(x, y, z), позволяющее недоверенному
субъекту создать доверенного субъекта из потенциального доверенного субъекта.

Правила преобразования состояний ФС ДП-модели

Правило Исходное состояние Результирующее состояние
G= (S, E, R ∪ A ∪ F , H) G′ = (S ′, E ′, R′ ∪A′ ∪F ′, H ′)

1 2 3
take_right(αr, x, y, z) x ∈ NS ∩ S, y ∈ S, S ′ = S, E ′ = E, A′ = A, H ′ =

z ∈ E \ FSE, x 6= z, =H, F ′ = F , R′ = R ∪ {(x, z,
αr ∈ Rr, (x, y, ownr) ∈ R, αr)}
(y, z, αr) ∈ R

grant_right(αr, x, y, z) x ∈ NS ∩ S, y ∈ S, z ∈ E S ′ = S, E ′ = E, A′ = A, H ′ =
\ FSE, y 6= z, αr ∈ Rr, = H, F ′ = F , R′ = R ∪ {(y, z,
(x, y, ownr) ∈ R, (x, z, αr)}
αr) ∈ R

own_take(αr, x, y) x ∈ S, y ∈ E, αr ∈ Rr, (x, S ′ = S, E ′ = E, A′ = A, H ′ =
y, ownr) ∈ R = H, F ′ = F , R′ = R ∪ {(x, y,

αr)}
create_entity(x, y, z) x ∈ S, y ∈/ E, z ∈ E \S, S ′ = S, E ′ = E ∪ {y}, A′ =

(x, z, writer) ∈ R = A, F ′ = F , H ′(z) = H(z)
∪ {y}, H ′(y) = ∅, для e ∈ E
\ {z} выполняется равенство
H ′(e) = H(e), R′ = R ∪ {(x, y,
ownr)}

create_subject(x, y, z) x ∈ S, y ∈ E, z ∈/ E, (x, S ′ = S ∪ {z}, E ′ = E ∪ {z},
y, executer) ∈ R A′ = A, F ′ = F , H ′(x) = H(x)

∪ {z}, H ′(z) = ∅, для e ∈ E
\ {x} выполняется равенство
H ′(e) = H(e), R′ = R ∪ {(x, z,
ownr)}

potential_subject(x, y, z) x ∈ NS ∩ S, y ∈ PS, z ∈/ S ′ = S ∪ {z}, FSS ’ = FSS
E, и для каждой e ∈ E ∪ {z}, E ′ = E ∪ {z}, A′ =
такой, что e ∈ ]y[, суще- = A, F ′ = F , H ′(x) = H(x)
ствует (e, x, writem) ∈ F ∪ {z}, H ′(z) = ∅, для e ∈ E

\ {x} выполняется равенство
H ′(e) = H(e), R′ = R ∪ {(x,
z, ownr)} ∪ {(z, e, αr): (y, e,
αr) ∈ R}



Подходы к построению ДП-модели файловых систем 99

П р о д о л ж е н и е т а б л и ц ы

1 2 3
know(x, y) x ∈ NS ∩ S, y ∈ S, x 6= y, S ′ = S, E ′ = E, A′ = A, H ′ =

и для каждой e ∈ E та- =H, F ′ = F , R′ = R ∪ {(x, y,
кой, что e ∈ ]y[, суще- ownr)}
ствует (e, x, writem) ∈ F

control(x, y, z) x ∈ NS ∩ S, y ∈ S, x 6= y, S ′ = S, E ′ = E, A′ = A, H ′ =
z ∈ E, z ∈ [y] и или x = z, =H, F ′ = F , R′ = R ∪ {(x, y,
или (x, z, writem) ∈ F ownr)}

access_write(x, y) x ∈ FSS ∪ (NS ∩ S), y ∈ S ′ = S, E ′ = E, R′ = R, H ′ =
E, (x, y, writer) ∈ R =H, A′ = A ∪ {(x, y, writea)},

F ′ = F ∪ {(x, y, writem)}
access_read(x, y) x ∈ FSS ∪ (NS ∩ S), y ∈ S ′ = S, E ′ = E, R′ = R, H ′ =

E, (x, y, read r) ∈ R =H, A′ = A ∪ {(x, y, reada)},
F ′ = F ∪ {(y, x, writem)}

control(x, y, z) x ∈ NS ∩ S, y ∈ S, x 6= y, S ′ = S, E ′ = E, A′ = A, H ′ =
z ∈ E, z ∈ [y] и или x = z, =H, F ′ = F , R′ = R ∪ {(x, y,
или (x, z, writem) ∈ F ownr)}

find(x, y, z) x, y ∈ S, z ∈ E, x 6= z, и S ′ = S, E ′ = E, R′ = R, A′ =
либо x = y, x ∈ LS ∩ S =A, H ′ = H, F ′ = F ∪ {(x, z,
и (x, z, writea) ∈ A, ли- writem)}
бо x 6= y и {(x, y, α), (y,
z, β)} ⊂ R ∪ A ∪ F , где
если x ∈ LS ∩ S, то α ∈
{writea, writem}, если x ∈
NS ∩ S, то α ∈ {writer,
writem}, если y ∈ LS ∩ S,
то β = {writea, writem},
если y ∈ NS ∩ S, то β ∈
{writer, writem}

post(x, y, z) x, z ∈ S, y ∈ E, x 6= z, S ′ = S, E ′ = E, R′ = R, A′ =
{(x, y, α), (z, y, β)} ⊂ R =A, H ′ = H, F ′ = F ∪ {(x, z,
∪ A ∪ F , где если x ∈ writem)}
LS ∩ S, то α ∈ {writea,
writem}, если x ∈ NS ∩ S,
то α ∈ {writer, writem},
если z ∈ LS ∩ S, то β =
= reada, если z ∈ NS ∩ S,
то β = read r



100 П.В. Буренин

О к о н ч а н и е т а б л и ц ы

1 2 3
pass(x, y, z) y ∈ S, x, z ∈ E, x 6= z, S ′ = S, E ′ = E, R′ = R, A′ =

и либо y = z, y ∈ LS =A, H ′ = H, F ′ = F ∪ {(x, z,
∩ S и (y, x, reada) ∈ A, writem)}
либо y 6= z и {(y, x, β),
(y, z, α)} ⊂ R ∪ A ∪ F ,
где если y ∈ LS ∩ S, то
α ∈ {writea, writem}, β =
= reada, если y ∈ NS ∩ S,
то α ∈ {writer, writem},
β = read r

Правило преобразования состояний potential_subject(x, y, z) позволяет недоверенному
субъекту x, реализовавшему к себе информационные потоки по памяти от всех сущ-
ностей, параметрически ассоциированных с потенциальным доверенным субъектом y,
создать соответствующего y доверенного субъекта z (рис. 2). При этом субъект z по-
лучает все права доступа субъекта y, субъект x получает доступ владения ownr к
субъекту z.

При анализе условий реализации запрещенных информационных потоков по па-
мяти будем использовать следующие определения.

Определение 5. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) —начальное состояние
системы Σ(G*, OP, G0). Запрещенным информационным потоком по памяти является
информационный поток от сущности e ∈ FSE, защищенной ФС, к недоверенному субъ-
екту x ∈ NS ∩ S0 в случае, когда в начальном состоянии G0 субъект x не имеет прав
доступа read r или ownr к сущности-образу fs(e) ∈ E, соответствующей сущности e.

Определение 6. В рамках ФС ДП-модели будем говорить, что система Σ(G*,
OP, G0) является безопасной в случае, когда невозможен переход системы в состояние,
в котором реализуется запрещенный информационный поток по памяти, удовлетворя-
ющий условиям определения 5.

Определение 7. Нарушитель в рамках ФС ДП-модели— любой недоверенный
субъект системы.

Примеры разрешенных и запрещенных информационных потоков по памяти при-
ведены на рис. 3.

Анализ траекторий системы без получения недоверенными субъектами
прав доступа владения к доверенным субъектам.

Рассмотрим частный случай, когда при реализации запрещенных информационных
потоков по памяти недоверенные субъекты не применяют правила вида control(x, y, z),
know(x, y) или potential_subject(x, y, z) для получения прав доступа владения к дове-
ренным субъектам системы. Дадим определение.

Определение 8. Назовем траекторию функционирования системы Σ(G*, OP)
траекторией без получения недоверенными субъектами прав доступа владения к до-
веренным субъектам, если она является траекторией без кооперации доверенных и
недоверенных субъектов для передачи прав доступа и реализации информационных



Подходы к построению ДП-модели файловых систем 101

Рис. 2. Пример применения правила potential_subject(x, y, z)

потоков по памяти, и при ее реализации недоверенные субъекты не инициируют вы-
полнение правил вида control(x, y, z), know(x, y) и potential_subject(x, y, z).

Определение 9. Назовем состояние G системы Σ(G*, OP) безопасным относи-
тельно прав доступа, когда в нем недоверенные субъекты не обладают правами досту-
па к доверенным субъектам.

Определение 10. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние си-
стемы Σ(G*, OP) и сущности x, y ∈ E0, где x 6= y. Определим предикат
simple_can_write_memory(x, y, G0), который будет истинным тогда и только тогда,
когда существуют состояния G1, . . . , GN = (SN , EN , RN ∪ AN ∪ FN , HN) и правила
преобразования состояний op1, . . . , opN , где N > 0, такие, что траектория G0 `op1 G1

`op2 . . . `op GN является траекторией без получения недоверенными субъектами прав
N

доступа владения к доверенным субъектам и (x, y, writem) ∈ FN .
В рамках ФС ДП-модели с учетом предположений 1–3 воспользуемся определенны-

ми и обоснованными в БК ДП-модели и классической модели Take-Grant необходимы-
ми и достаточными условиями истинности предиката can_share(α, x, y, G0). При этом
доверенные субъекты с учетом предположения 3 могут рассматриваться как объекты
модели Take-Grant.



102 П.В. Буренин

Рис. 3. Примеры информационных потоков по памяти: (e1, x,
writem) —разрешенный информационный поток; (e2, x,
writem) — запрещенный информационный поток

Определение 11. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы
Σ(G*, OP), в котором существуют субъект x ∈ S0 и сущность y ∈ E0, где x 6= y, и пусть
право доступа α ∈ Rr. Определим предикат simple_can_share(α, x, y, G0), который
будет истинным тогда и только тогда, когда существуют состояния G1, . . . , GN =
=(SN , EN , RN ∪AN ∪ FN , HN) и правила преобразования состояний op1, . . . , opN , где
N > 0, такие, что G0 ` op1G1 ` op2 . . . ` op GN является траекторией без получения

N

недоверенными субъектами прав доступа владения к доверенным субъектам, и (x, y,
α) ∈ RN .

Определение 12. Мостом в состоянии G между двумя недоверенными субъек-
тами называется путь в графе-состоянии, удовлетворяющий одному из условий:
— субъекты соединены ребром, без учета направления помеченным правом доступа

ownr;
— субъекты соединены путем, проходящим через доверенных субъектов, словарная

запись которого имеет вид: −o−w−→nr* ←ow−−n−r*, где символ «*» означает многократное, в
том числе нулевое, повторение.
Определение 13. Пролетом моста в состоянии G называется путь с началом в

недоверенном субъекте и концом в доверенном субъекте, проходящий через доверен-
ных субъектов, словарная запись которого имеет вид: −o−w−→nr*, где символ «*» означает
многократное повторение.

Определение 14. Два недоверенных субъекта x и y в состоянии G являют-
ся own-связанными, когда существует последовательность недоверенных субъектов
s1, . . . , sn, где n > 2, таких, что s1 = x, sn = y, и каждая пара si, si+1 соединена
мостом, где 1 6 i < n.



Подходы к построению ДП-модели файловых систем 103

Утверждение 8. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы
Σ(G*, OP), в котором существуют субъект x ∈ S0, сущность y ∈ E0, где x 6= y, и пусть
право доступа α ∈ Rr. Предикат simple_can_share(α, x, y, G0) является истинным
тогда и только тогда, когда выполняются условия.

Условие 1. Существует субъект s ∈ S0 такой, что или (s, y, α) ∈ R0, или (s, y,
ownr) ∈ R0.

Условие 2. Существуют недоверенные субъекты x′, s′ ∈ NS ∩ S0 такие, что выпол-
няются условия:
— или x = x′, или x′ соединен с x пролетом моста;
— или s = s′, или s′ соединен с s пролетом моста;
— x′ и s′ являются own-связанными.

Доказательство. Справедливость данного утверждения обосновывается в рам-
ках классической модели Take-Grant.

Определим и обоснуем алгоритмически проверяемые необходимые и достаточные
условия истинности предиката simple_can_write_memory(x, y, G0).

Теорема 1. Пусть G0 = (S0, E0, R0 ∪A0 ∪F0, H0) — состояние системы Σ(G∗, OP )
и сущности x, y ∈ E0, где x 6= y. Предикат simple_can_write_memory(x, y, G0) явля-
ется истинным тогда и только тогда, когда существует последовательность сущностей
e1, . . . , em ∈ E0, где e1 = x, em = y и m > 2, таких, что для каждого i =1, ..., m − 1
выполняется одно из условий.

Условие 1. ei ∈ LS ∩ S0 и или (ei, ei+1, writem) ∈ F0, или (ei, ei+1, writea) ∈ A0.
Условие 2. ei ∈ FSS 0 ∪ (NS ∩S0) и или (ei, ei+1, writem) ∈ F0, или истинен предикат

simple_can_share(writer, ei, ei+1, G0).
Условие 3. ei+1 ∈ LS ∩ S0 и (ei+1, ei, reada) ∈ A0.
Условие 4. ei+1 ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат simple_can_share(read r,

ei+1, ei, G0).
Условие 5. ei ∈ NS ∩ S0, ei+1 ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат

simple_can_share(ownr, ei, ei+1, G0).
Условие 6. ei+1 ∈ NS ∩ S0, ei ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат

simple_can_share(ownr, ei+1, ei, G0).
Доказательство. Докажем достаточность выполнения условий теоремы для ис-

тинности предиката simple_can_write_memory(x, y, G0).
Пусть существует последовательность сущностей e1, . . . , em ∈ E0, где e1 = x, em = y

и m > 2, таких, что выполняются условия теоремы. Выполним доказательство индук-
цией по длине m последовательности сущностей.

Пусть m= 2. Возможны шесть случаев.
Первый случай: x ∈ LS ∩ S0 и или (x, y, writem) ∈ F0, или (x, y, writea) ∈ A0. Если

(x, y, writem) ∈ F0, то предикат simple_can_write_memory(x, y, G0) истинен. Если
(x, y, writea) ∈ A0, то положим op1 = find(x, x, y), G0 ` op1G1. Тогда (x, y, writem) ∈ F1

и предикат simple_can_write_memory(x, y, G0) истинен.
Второй случай: x ∈ FSS 0 ∪ (NS ∩ S0) и или (x, y, writem) ∈ F0, или ис-

тинен предикат simple_can_share(writer, x, y, G0). Если (x, y, writem) ∈ F0,
то предикат simple_can_write_memory(x, y, G0) истинен. Если истинен предикат
simple_can_share(writer, x, y, G0), то по определению 11 существуют состояния G1,
. . . , GN и правила преобразования состояний op1, . . . , opN , где N > 0, такие, что



104 П.В. Буренин

G0 `op1 G1 `op2 . . . ` op GN является траекторией без получения недоверенными субъ-
N

ектами прав доступа владения к доверенным субъектам и (x, y, writer) ∈ RN . Пусть
opN+1 = access_write(x, y) и GN ` op G

N+ N+1. Тогда (x, y, writem) ∈ FN+1 и предикат
1

simple_can_write_memory(x, y, G0) истинен.
Третий случай: y ∈ LS ∩ S0 и (y, x, reada) ∈ A0. Положим op1 = pass(x, y, y),

G0 ` op1G1. Тогда (x, y, writem) ∈ F1 и предикат simple_can_write_memory(x, y, G0)
истинен.

Четвертый случай: y ∈ FSS0 ∪ (NS ∩ S0) и истинен предикат simple_can_
_share(readr, y, x,G0). Тогда по определению 11 существуют состояния G1, . . . , GN

и правила преобразования состояний op1, . . ., opN , где N > 0, такие, что G0 `op1
G1 `op2 . . . `op GN является траекторией без получения недоверенными субъек-

N

тами прав доступа владения к доверенным субъектам и (y, x, readr) ∈ RN . Пусть
opN+1 = access_read(y, x) и GN `op G

N+ N+1. Тогда (x, y, writem) ∈ FN+1 и предикат
1

simple_can_write_memory(x, y,G0) истинен.
Пятый случай: x ∈ NS ∩ S0, y ∈ FSS0 ∪ (NS ∩ S0) и истинен преди-

кат simple_can_share(ownr, x, y,G0). По определению 11 существуют состояния
G1, . . . , GN и правила преобразования состояний op1, . . . , opN , где N > 0, такие, что
G0 `op1 G1 `op2 . . . `op GN является траекторией без получения недоверенными

N

субъектами прав доступа владения к доверенным субъектам и (x, y, ownr) ∈ RN . Вос-
пользуемся предположением базовой ДП-модели, согласно которому для любого субъ-
екта в любом состоянии системы существует сущность-контейнер, в составе которой
он может создать новую сущность. Следовательно, существует сущность-контейнер
e ∈ EN , в составе которой субъект x может создать новую сущность. Пусть opN+1 =
= create_entity(x, z, e), opN+2 = own_take(writer, x, z), opN+3 = own_take(readr, x, z),
opN+4 = grant_right(readr, x, y, z), opN+5 = access_read(y, z), opN+6 = post(x, z, y),
и GN `op G

N+ N+1 `op . . . `
N+2 op G

N+6 N+6. Тогда (x, y, writem) ∈ FN+6 и предикат
1

simple_can_write_memory(x, y,G0) истинен. На рис. 4 приведена последовательность
преобразований состояний, при этом показаны только ребра графов-состояний, кото-
рые необходимы для применения правил.

Шестой случай: y ∈ NS ∩ S0, x ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат
simple_can_share(ownr, y, x, G0). Доказательство для шестого случая осуществляется
аналогично доказательству для пятого случая.

Докажем индуктивный шаг. Пусть m > 2 и утверждение теоремы верно для всех
последовательностей сущностей длины k < m. Докажем, что утверждение теоремы
верно для всех последовательностей сущностей длины m.

Пусть e1, . . . , em ∈ E0 —последовательность сущностей, где e1 = x, em = y. Воз-
можны два случая: x ∈ S0 или x ∈ E0 \ S0.

Первый случай: x ∈ S0. Положим em−1 = z. Тогда по предположению индукции
существуют состояния G1, . . . , GN и правила преобразования состояний op1, . . . , opN ,
где N > 0, такие, что G0 ` op1G1 ` op2 . . . ` op G

N N является траекторией без получения
недоверенными субъектами прав доступа владения к доверенным субъектам и (x, z,
writem) ∈ FN .

Если z ∈ S0, то по предположению индукции существуют состоянияGN+1, . . . , GN+K

и правила преобразования состояний opN+1, . . . , opN+K , гдеK > 0, такие, чтоGN `opN+1

GN+1 `op . . . `
N+ op G в я т я р

N+K N+K я л е с т аекторией без получения недоверенными
2

субъектами прав доступа владения к доверенным субъектам и (z, y, writem) ∈ FN+K .
Пусть opN+K+1 = find(x, z, y), тогда GN+K ` op G

N+K+ N+K+1 и (x, y, writem) ∈ F
1 N+K+1,

следовательно, предикат simple_can_write_memory(x, y, G0) истинен.



Подходы к построению ДП-модели файловых систем 105

Рис. 4. Случай x ∈ NS ∩ S0, y ∈ FSS 0 ∪ (NS ∩ S0) и истинен
предикат can_share(ownr, x, y, G0)

Если z ∈ E0\S0, то выполняется одно из следующих условий:
— y ∈ LS ∩ S0 и (y, z, reada) ∈ A0;
— y ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат simple_can_share(read r, y, z, G0).

Если y ∈ LS ∩ S0 и (y, z, reada) ∈ A0, то пусть M = N .
Если y ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат simple_can_share(read r, y, z, G0),

то по определению 11 существуют состояния GN+1, . . . , GN+K и правила преобразо-
вания состояний opN+1, . . . , opN+K , где K > 0, такие, что GN ` op G

N+1 N+1 ` op . . .
N+2

` op G я
N+K N+K вляется траекторией без получения недоверенными субъектами прав

доступа владения к доверенным субъектам и (y, z, read r) ∈ RN+K . Пусть opN+K+1 =
= access_read(y, z) и M = N +K + 1.

Положим opM+1 = post(x, z, y), GM ` op G
M+ M+1. Тогда (x, y, write

1 m) ∈ FM+1 и
предикат simple_can_write_memory(x, y, G0) истинен.

Второй случай: x ∈ E0\S0. Положим e2 = z. Тогда по условию теоремы
z ∈ S0 и по предположению индукции существуют состояния G1, . . . , GN и прави-
ла преобразования состояний op1, . . . , opN , где N > 0, такие, что G0 `op1 G1 `op2
. . . `op GN является траекторией без получения недоверенными субъектами прав до-

N

ступа владения к доверенным субъектам и (z, y, writem) ∈ FN . При этом выполняется
одно из следующих условий:
— z ∈ LS ∩ S0 и (z, x, reada) ∈ A0;
— z ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат simple_can_share(read r, z, x, G0).

Если z ∈ LS ∩ S0 и (z, x, reada) ∈ A0, то пусть M = N .
Если z ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат simple_can_share(read r, z, x, G0),

то по определению 11 существуют состояния GN+1, . . . , GN+K и правила преобра-
зования состояний opN+1, . . . , opN+K , где K > 0, такие, что GN `op G

N+ N+1 `1 opN+2

. . . `op G я
N+K N+K вляется траекторией без получения недоверенными субъектами прав



106 П.В. Буренин

доступа владения к доверенным субъектам и (z, x, read r) ∈ RN+K . Пусть opN+K+1 =
= access_read(z, x) и M = N +K + 1.

Положим opM+1 = pass(x, z, y), GM ` op G
M+ M+1. Тогда (x, y, writem) ∈ FM+1 и

1

предикат simple_can_write_memory(x, y, G0) истинен.
Индуктивный шаг доказан. Доказательство достаточности выполнения условий

теоремы для истинности предиката simple_can_write_memory(x, y, G0) выполнено.
Докажем необходимость выполнения условия теоремы для истинности предиката

simple_can_write_memory(x, y, G0).
Пусть истинен предикат simple_can_write_memory(x, y, G0), при этом по опре-

делению 10 существуют состояния G1, . . . , GN и правила преобразования состояний
op1, . . . , opN , где N > 0, такие, что траектория G0 ` op1G1 ` op2 . . . ` op GN является

N

траекторией без получения недоверенными субъектами прав доступа владения к дове-
ренным субъектам и (x, y, writem) ∈ FN . Среди всех этих последовательностей выберем
ту, у которой длина N является минимальной. Проведем доказательство индукцией
по длине N последовательности преобразований состояний.

Пусть N = 0, тогда (x, y, writem) ∈ F0, m= 2 и условие 1 или 2 теоремы выполнено.
Пусть N > 0 и утверждение теоремы верно для всех последовательностей преоб-

разований состояний длины l < N . Тогда (x, y, writem) ∈/ FN−1 и существует правило
преобразования состояний opN такое, что GN−1 ` op GN и (x, y, writem) ∈ FN .N

Из определения правил преобразования состояний следует, что возможны семь слу-
чаев:
— x ∈ FSS0 ∪ (NS ∩ S0), (x, y, writer) ∈ RN−1, opN = access_write(x, y);
— y ∈ FSS0 ∪ (NS ∩ S0), (y, x, readr) ∈ RN−1 и opN = access_read(y, x);
— x ∈ LS ∩ S0, (x, y, writea) ∈ AN−1, opN = find(x, x, y);
— x ∈ S0 и существует субъект z ∈ SN−1 такой, что opN = find(x, z, y),
{(x, z, α), (z, y, β)} ⊂ RN−1 ∪ AN−1 ∪ FN−1, где если x ∈ LS ∩ S0, то
α ∈ {writea, writem}, если x ∈ NS ∩ S0, то α ∈ {writer, writem}, если z ∈ LS ∩ SN−1,
то β = {writea, writem}, если z ∈ NS ∩ SN−1, то β ∈ {writer, writem};

— x, y ∈ S0 и существует сущность z ∈ EN−1 такая, что opN = post(x, z, y),
{(x, z, α), (y, z, β)} ⊂ RN−1 ∪ AN−1 ∪ FN−1, где если x ∈ LS ∩ S0, то
α ∈ {writea, writem}, если x ∈ NS ∩S0, то α ∈ {writer, writem}, если y ∈ LS ∩S0, то
β = reada, если y ∈ NS ∩ S0, то β = readr;

— y ∈ LS ∩ S0, (y, x, reada) ∈ AN−1, opN = pass(x, y, y);
— x, y ∈ E0 и существует субъект z ∈ SN−1, opN = pass(x, z, y), {(z, x, β), (z, y, α)} ⊂

RN−1 ∪ AN−1 ∪ FN−1, где если z ∈ LS ∩ SN−1, то α ∈ {writea, writem}, β = reada,
если z ∈ NS ∩ SN−1, то α ∈ {writer, writem}, β = readr.
В первом случае истинен предикат simple_can_share(writer, x, y, G0), и условие 2

теоремы выполнено.
Во втором первом случае истинен предикат simple_can_share(read r, y, x, G0), и

условие 4 теоремы выполнено.
Третий случай: x ∈ LS ∩ S0, (x, y, writea) ∈ AN−1, opN = find(x, x, y). Предполо-

жим (x, y, writea) ∈/ A0, тогда по предположению 3 доверенный субъект x ∈ FSS 0 и
существует 0 6 M < N такое, что opM = access_write(x, y). Следовательно, выпол-
няется условие (x, y, writem) ∈ FM , противоречие с минимальностью N . Значит, (x, y,
writea) ∈ A0, и условие 1 теоремы выполнено.

В четвертом случае opN = find(x, z, y), {(x, z, α), (z, y, β)} ⊂ RN−1 ∪AN−1 ∪FN−1,
из минимальности N следует, что z ∈ S0, и выполняются условия:



Подходы к построению ДП-модели файловых систем 107

— если x ∈ LS ∩ S0, то α ∈ {writea, writem};
— если x ∈ NS ∩ S0, то α ∈ {writer, writem};
— если z ∈ LS ∩ S0, то β = {writea, writem};
— если z ∈ NS ∩ S0, то β ∈ {writer, writem}.

Пусть x ∈ LS ∩ S0. Если (x, z, writea) ∈ AN−1, то по аналогии с третьим случа-
ем получаем, что (x, z, writea) ∈ A0. Если x ∈ LS ∩ S0 и (x, z, writem) ∈ FN−1, то
истинен предикат simple_can_write_memory(x, z, G0) с длиной последовательности
преобразований состояний меньше N . Следовательно, по предположению индукции
существует последовательность сущностей, удовлетворяющая условиям теоремы.

Пусть x ∈ NS ∩ S0. Если (x, z, writer) ∈ RN−1, то истинен предикат
simple_can_share(writer, x, z, G0). Если (x, z, writem) ∈ FN−1, то истинен предикат
simple_can_write_memory(x, z, G0) с длиной последовательности преобразований со-
стояний меньше N . Следовательно, по предположению индукции существует последо-
вательность сущностей, удовлетворяющая условиям теоремы.

Аналогично рассматриваются условия z ∈ LS ∩ S0 и z ∈ NS ∩ S0. Таким образом,
объединяя последовательности сущностей для каждого из возможных сочетаний пар
условий, получаем, что в четвертом случае выполняются условия теоремы.

В пятом случае существует сущность z ∈ EN−1 такая, что opN = post(x, z, y),
{(x, z, α), (y, z, β)} ⊂ RN−1 ∪ AN−1 ∪ FN−1, и выполняются условия:
— если x ∈ LS ∩ S0, то α ∈ {writea, writem};
— если x ∈ NS ∩ S0, то α ∈ {writer, writem};
— если y ∈ LS ∩ S0, то β = reada;
— если y ∈ NS ∩ S0, то β = read r.

Если z ∈ E0, то шаг индукции обосновывается аналогично четвертому случаю.
Если z ∈/ E0, то существуют 1 6 M < N , субъект s ∈ SM−1, сущность-контейнер
e ∈ EM−1 такие, что opM = create_entity(s, z, e). Из минимальности N следует, что
выполняются условия s ∈ S0 и сущность-контейнер e ∈ E0. Из всех последователь-
ностей преобразований выберем ту, в которой M = 1. Рассмотрим состояние G1, где
G0 `op1 G1, S1 = S0, E1 = E0 ∪ {z}, R1 = R0 ∪ {(s, z, ownr)}, A1 = A0, F1 = F0. Так как
(x, z, α) ∈ RN−1 ∪ AN−1 ∪ FN−1, то истинен предикат simple_can_write_memory(x, z,
G1) с длиной последовательности состояний меньше N . Таким образом, получаем, что
существуют сущности e1, . . . , ek, где e1 = x, ek = s и k > 2, удовлетворяющие услови-
ям теоремы в состоянии G1, а следовательно, в состоянии G0. Аналогично получаем,
что существуют сущности ek, . . . , ek+m, где ek = s, ek+m = y и m > 1, удовлетво-
ряющие условиям теоремы в состоянии G0. Значит, в пятом случае условия теоремы
выполнены.

Седьмой случай рассматривается аналогично третьему случаю.
Восьмой случай рассматривается аналогично четвертому и пятому случаям.
Индуктивный шаг доказан. Обоснована необходимость выполнения условий теоре-

мы для истинности предиката simple_can_write_memory(x, y, G0).
Рассмотрим условия истинности предиката simple_can_write_memory(e, x, G0)

для случая, когда сущность x является недоверенным субъектом и сущность e за-
щищена ФС.

Следствие 1. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) —начальное состояние си-
стемы Σ(G∗, OP ,G0), безопасное относительно прав доступа, в котором существу-
ют сущность e ∈ FSE0, недоверенный субъект x ∈ NS ∩ S0. Предикат simple_can_



108 П.В. Буренин

_write_memory(e, x, G0) (недоверенный субъект x пытается реализовать запрещен-
ный информационный поток по памяти от сущности e) является истинным тогда и
только тогда, когда существует доверенный субъект s ∈ FSS 0 такой, что он обладает
правами доступа на чтение и запись к сущностям e и fs(e), и существует последова-
тельность сущностей e1, . . . , em ∈ E0, где e1 = x, em = fs(e) и m > 2, таких, что для
каждого i =1, ..., m− 1 выполняется одно из условий.

Условие 1. ei ∈ LS ∩ S0, ei+1 ∈ E0 \ NS и или (ei, ei+1, writem) ∈ F0, или (ei, ei+1,
writea) ∈ A0.

Условие 2. ei ∈ NS∩S0, ei+1 ∈ E0 \ LS и истинен предикат simple_can_share(writer,
ei, ei+1, G0).

Условие 3. ei+1 ∈ LS ∩ S0, ei ∈ E0 \ NS и (ei+1, ei, reada) ∈ A0.
Условие 4. ei+1 ∈ NS ∩S0, ei ∈ E0 \ LS и истинен предикат simple_can_share(read r,

ei+1, ei, G0).
Условие 5. ei, ei+1 ∈ NS∩S0 и истинен предикат simple_can_share(ownr, ei, ei+1, G0).
Условие 6. ei, ei+1 ∈ NS∩S0 и истинен предикат simple_can_share(ownr, ei+1, ei, G0).
Доказательство. В соответствии с предположениями 1 и 2 только доверенные

субъекты из множества FSS 0 могут обладать правами доступа к сущностям, защищен-
ным ФС. Значит, субъекты, не входящие во множество FSS 0, могут обладать правами
доступа, реализовывать информационные потоки или доступы только к сущностям-
образам из множества fs(FSE 0). При этом для каждой сущности из множества FSE 0

всегда существует доверенный субъект из множества FSS 0 или потенциальный дове-
ренный субъект из множества PS 0, обладающий правами доступа на чтение и запись к
сущности и к соответствующей ей сущности-образу (для каждой e ∈ FSE 0 существу-
ет субъект s ∈ FSS 0 ∪ PS 0, обладающий правами доступа (s, e, readr), (s, e, writer),
(s, fs(e), readr), (s, fs(e), writer)).

В соответствии с предположением 1 в начальном состоянии отсутствуют досту-
пы к недоверенным субъектам и информационные потоки с участием недоверенных
субъектов.

Так как начальное состояние безопасно относительно прав доступа, то для
любых доверенного субъекта s1 ∈ FSS0 и субъекта s2 ∈ FSS0 ∪ (NS ∩ S0)
предикаты simple_can_share(writer, s1, s2, G0), simple_can_share(writer, s2, s1, G0),
simple_can_share(readr, s1, s2, G0), simple_can_share(readr, s2, s1, G0), simple_can_
_share(ownr, s1, s2, G0) и simple_can_share(ownr, s2, s1, G0) являются ложными.

Таким образом, утверждение следствия следует из теоремы 1.
В соответствия с утверждением следствия 1, если начальное состояние системы

безопасное относительно прав доступа, то необходимым условием истинности предика-
та simple_can_write_memory(e, x, G0), где сущность e ∈ FSE 0, недоверенный субъект
x ∈ NS ∩S0, является наличие доверенного субъекта s ∈ FSS 0 такого, что он обладает
правами доступа на чтение и запись к сущностям e и fs(e).

Следствие 2. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) —начальное состояние си-
стемы Σ(G∗, OP ,G0), безопасное относительно прав доступа, в котором отсутствуют
доступы или информационные потоки к или от доверенных субъектов, не существует
недоверенных субъектов x ∈ NS ∩ S0 и сущностей e ∈ FSE 0 таких, что выполняются
условия или (x, fs(e), read r) ∈ R0, или (x, fs(e), ownr) ∈ R0. Пусть также в системе
могут реализовываться только траектории без получения недоверенными субъектами
прав доступа владения к доверенным субъектам. Тогда система является безопасной.



Подходы к построению ДП-модели файловых систем 109

Доказательство. Утверждение следует из теоремы 1 и следствия 1.
Таким образом, в следствии 2 обоснованы достаточные условия безопасности систе-

мы для случая, когда в ней могут реализовываться только траектории без получения
недоверенными субъектами прав доступа владения к доверенным субъектам.

Анализ траекторий системы с возможным получением недоверенными
субъектами прав доступа владения к доверенным субъектам.

Рассмотрим общий случай, когда при реализации запрещенных информационных
потоков по памяти недоверенные субъекты могут применять правила вида control(x,
y, z), know(x, y) или potential_subject(x, y, z) для получения прав доступа владения к
доверенным субъектам системы. Дадим определение.

Определение 15. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние систе-
мы Σ(G*, OP) и сущности x, y ∈ E0, где x 6= y. Определим предикат
can_write_memory(x, y,G0), который будет истинным тогда и только тогда, когда
существуют состояния G1, . . . , GN = (SN , EN , RN ∪ AN ∪ FN , HN) и правила преоб-
разования состояний op1, . . . , opN , где N > 0, такие, что траектория G0 `op1 G1 `op2
. . . `op GN является траекторией без кооперации доверенных и недоверенных субъ-

N

ектов для передачи прав доступа и реализации информационных потоков по памяти
и (x, y, writem) ∈ FN .

Так как при использовании правил вида control(x, y, z), know(x, y) или potential_
_subject(x, y, z) права доступа используются для реализации информационных пото-
ков по памяти, а информационные потоки по памяти могут быть использованы для
получения прав доступа, то необходимые условия реализации запрещенных информа-
ционных потоков по памяти должны быть определены рекурсивно, что является труд-
нореализуемой задачей. Таким образом, определим и обоснуем достаточные условия
реализации запрещенных информационных потоков по памяти. Дадим определения.

Определение 16. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы
Σ(G*, OP) и недоверенный субъект x ∈ NS ∩S0, субъект y ∈ S0, где x 6= y. Определим
предикат can_share_own(x, y, G0, LS), который будет истинным тогда и только тогда,
когда существуют состояния G1, . . . , GN = (SN , EN , RN ∪AN ∪FN , HN) и правила пре-
образования состояний op1, . . . , opN , где N > 0, такие, что траектория G0 ` op1G1 ` op2
. . . ` op GN является траекторией без кооперации доверенных и недоверенных субъ-

N

ектов для передачи прав доступа и реализации информационных потоков по памяти
и (x, y, ownr) ∈ RN .

Определение 17. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние систе-
мы Σ(G∗, OP ) и недоверенный субъект x ∈ NS ∩ S0, субъект или потенци-
альный доверенный субъект y ∈ S0 ∪ PS, где x 6= y. Определим предикат
directly_can_share_own(x, y,G0), который будет истинным тогда и только тогда, ко-
гда существует последовательность субъектов s1, . . . , sm ∈ S0 ∪PS, где s1 = x, sm = y
и m > 2, таких, что для каждого i = 1, . . . ,m− 1 справедливо неравенство si 6= si+1 и
выполняется одно из условий:
— si+1 ∈/ FSS 0 и si ∈ [si+1] (каждый доверенный субъект из множества FSS 0 по пред-

положению 2 является функционально корректным);
— истинен предикат simple_can_share(ownr, si, si+1, G0);
— si+1 ∈/ FSS 0 и существует сущность e ∈ [si+1] такая, что истинен предикат

simple_can_write_memory(si, e, G0) (по предположению 2 невозможно получение



110 П.В. Буренин

к доверенному субъекту из множества FSS 0 права доступа владения с использова-
нием реализованного к нему информационного потока по памяти);

— для каждой сущности e ∈ ]si+1[ истинен предикат simple_can_write_memory(si, e,
G0).
Определим и обоснуем достаточные условия истинности предиката can_share_

_own(x, y, G0).
Утверждение 9. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние систе-

мы Σ(G*, OP), пусть также существуют недоверенный субъект x ∈ NS ∩ S0, субъ-
ект или потенциальный доверенный субъект y ∈ S0∪ PS, где x 6= y. Предикат
can_share_own(x, y, G0) является истинным в случае, когда существует последова-
тельность субъектов s1, . . . , sm ∈ S0 ∪ PS, где s1 = x, sm = y и m > 2, таких, что
выполняется одно из условий.

Условие 1. m = 2 и истинен предикат directly_can_share_own(x, y, G0).
Условие 2. m > 2 и для каждого i =1, ..., m− 2 выполняется одно из условий:

— si, si+1 ∈ NS ∩ S0 и истинны предикаты directly_can_share_own(si, si+1, G0),
directly_can_share_own(si+1, si+2, G0);

— i < m− 2,si, si+2 ∈ NS ∩ S0 и истинны предикаты directly_can_share_own(si, si+1,
G0), directly_can_share_own(si+2, si+1, G0);

— i < m − 2, si+1, si+2 ∈ NS ∩ S0 и истинны предикаты directly_can_share_own(si+1,
si, G0), directly_can_share_own(si+2, si+1, G0);

— si+1 ∈ NS ∩ S0 и истинны предикаты directly_can_share_own(si+1, si, G0, LS),
directly_can_share_own(si+1, si+2, G0, LS).
Доказательство. Доказательство теоремы выполняется аналогично доказа-

тельству в рамках ФПАС ДП-модели достаточности условий истинности предиката
can_share_own(x, y, G0).

Определим и обоснуем достаточные условия истинности предиката can_write_
_memory(x, y, G0).

Теорема 2. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы Σ(G*,
OP) и сущности x, y ∈ E0, где x 6= y. Предикат can_write_memory(x, y, G0) является
истинным в случае, когда существует последовательность сущностей e1, . . . , em ∈ E0,
где e1 = x, em = y и m > 2, таких, что для каждого i =1, ..., m− 1 выполняется одно
из условий.

Условие 1. ei ∈ LS ∩ S0 и или (ei, ei+1, writem) ∈ F0, или (ei, ei+1, writea) ∈ A0.
Условие 2. ei ∈ FSS 0 ∪ (NS ∩S0) и или (ei, ei+1, writem) ∈ F0, или истинен предикат

can_share(writer, ei, ei+1, G0).
Условие 3. ei+1 ∈ LS ∩ S0 и (ei+1, ei, reada) ∈ A0.
Условие 4. ei+1 ∈ FSS 0 ∪ (NS∩S0) и истинен предикат can_share(readr, ei+1, ei, G0).
Условие 5. ei ∈ NS ∩ S0, ei+1 ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат

can_share_own(ei, ei+1, G0).
Условие 6. ei+1 ∈ NS ∩ S0, ei ∈ FSS 0 ∪ (NS ∩ S0) и истинен предикат

can_share_own(ei+1, ei, G0).
Доказательство. Доказательство осуществляется аналогично обоснованию

достаточности условий теоремы 1 для истинности предиката simple_can_write_
_memory(x, y, G0).



Подходы к построению ДП-модели файловых систем 111

Рассмотрим условия истинности предиката can_write_memory(e, x, G0) для слу-
чая, когда сущность x является недоверенным субъектом и сущность e защищена ФС.

Следствие 3. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы Σ(G*,
OP), в котором существуют сущность e ∈ FSE 0, недоверенный субъект x ∈ NS ∩ S0,
и выполняются условия сущность fs(e) ∈/ FSE 0, и она не является параметрически
ассоциированной ни с одним субъектом. Пусть также существует доверенный субъект
z ∈ FSS 0 такой, что он обладает правами доступа на чтение и запись к сущностям e и
fs(e), и существует доверенный субъект z′ ∈ (LS∩S0)\ FSS 0 такой, что истинен преди-
кат can_share_own(x, z′, G0). Тогда предикат can_write_memory(e, x, G0) является
истинным.

Доказательство. Так как выполняется условие fs(e) ∈/ FSE 0 ∪ FSS 0 ∪ {e ∈ E0:
существует s ∈ S0 и e ∈ ]s[}, то по предположению 2 справедливо условие (z′, fs(e),
read r) ∈ R0. Следовательно, истинен предикат can_share(read r, x, fs(e), G0). Кроме
того, по предположению 2 являются истинными предикаты can_share(read r, z, e, G0)
и can_share(writer, z, fs(e), G0). Таким образом, выполнены условия теоремы 2, и
истинен предикат can_write_memory(e, x, G0). Следствие доказано.

Пример выполнения условия следствия 3 приведен на рис. 5.

Рис. 5. Пример выполнения условия следствия 3, где z ∈ FSS 0, e ∈ FSE 0

Следствие 4. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы Σ(G*,
OP), в котором существуют сущность e ∈ FSE 0 и недоверенный субъект x ∈ NS ∩ S0.
Пусть также существует доверенный субъект или потенциальный доверенный субъ-
ект y ∈ FSS 0 ∪ PS такой, что он обладает правами доступа на чтение и запись к
сущностям e и fs(e), и выполняется условие: для каждой сущности e′ ∈ ]y[ истинен
предикат simple_can_write_memory(x, e′, G0). Тогда предикат can_write_memory(e,
x, G0) является истинным.

Доказательство. По определению 17 истинен предикат directly_can_share_
_own(x, y,G0). Следовательно, по утверждению 2 истинен предикат can_share_own(x,
y, G0). Таким образом, выполнены условия теоремы 2 и истинен предикат can_write_
_memory(e, x, G0). Следствие доказано.

Рассмотрим достаточные условия, при выполнении которых является ложным пре-
дикат can_write_memory(e, x, G0), где сущность e защищена ФС, и субъект x является
недоверенным.

Утверждение 10. Пусть G0 = (S0, E0, R0 ∪ A0 ∪ F0, H0) — состояние системы
Σ(G∗, OP ), в котором существуют сущность e ∈ FSE0 и недоверенный субъект
x ∈ NS ∩ S0. Пусть также выполнены условия.

Условие 1. Не существует доверенных субъектов таких, что они обладает правами
доступа на чтение и запись к сущностям e и fs(e).

Условие 2. Для каждого потенциального доверенного субъекта y ∈ PS такого, что
он обладает правами доступа на чтение и запись к сущностям e и fs(e), и для любого



112 П.В. Буренин

субъекта x′ ∈ S0 существует сущность ey ∈ ]y[ такая, что выполняются условия (ey, x′,
writem) ∈/ F0, (x′, ey, writea) ∈/ A0, (x′, ey, writer) ∈/ R0, (x′, ey, ownr) ∈/ R0.

Тогда предикат can_write_memory(e, x, G0) является ложным.
Доказательство. Так как по условию 1 не существует доверенных субъектов

таких, что они обладает правами доступа на чтение и запись к сущностям e и fs(e),
то по предположениям 1 и 2 для реализации информационного потока от сущности
e необходимо создание такого доверенного субъекта y′∈ FSS из потенциального до-
веренного субъекта y ∈ PS с использованием правила potential_subject(x′, y, y′), где
x′ ∈ NS ∩S0. По условию 2 не существует недоверенного субъекта x′ ∈ NS ∩S0, удовле-
творяющего условиям применения правила potential_subject(x′, y, y′). Следовательно,
предикат can_write_memory(e, x, G0) является ложным. Утверждение доказано.

Таким образом, описаны и обоснованы достаточные условия, при выполнении ко-
торых в системе невозможна реализация запрещенного информационного потока по
памяти от сущности, защищенной ФС.

ЛИТЕРАТУРА
1. Девянин П.Н. Анализ безопасности управления доступом и информационными потоками

в компьютерных системах. М.: Радио и связь, 2006. 176 с.